
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>mmap: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/nomasters/haystack/storage/mmap/datafile.go (78.9%)</option>
				
				<option value="file1">github.com/nomasters/haystack/storage/mmap/index.go (75.3%)</option>
				
				<option value="file2">github.com/nomasters/haystack/storage/mmap/security.go (84.8%)</option>
				
				<option value="file3">github.com/nomasters/haystack/storage/mmap/store.go (68.8%)</option>
				
				<option value="file4">github.com/nomasters/haystack/storage/mmap/types.go (87.5%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package mmap

import (
        "encoding/binary"
        "fmt"
        "os"
        "sync"
        "sync/atomic"
        "syscall"
        "time"

        "github.com/nomasters/haystack/needle"
)

// DataFile represents a memory-mapped data file for storing needle records.
type DataFile struct {
        path      string
        file      *os.File
        mmap      []byte
        fileSize  int64
        capacity  uint64
        chunkSize int64
        mu        sync.RWMutex
        
        // Atomic counter for append position
        appendPos uint64
}

// readHeader safely reads the header from memory-mapped data using encoding/binary.
func (df *DataFile) readHeader() (*DataHeader, error) <span class="cov8" title="1">{
        if len(df.mmap) &lt; DataHeaderSize </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("file too small for header")
        }</span>
        
        <span class="cov8" title="1">header := &amp;DataHeader{}
        
        // Read magic bytes
        copy(header.Magic[:], df.mmap[0:8])
        
        // Read other fields using encoding/binary
        header.Version = binary.LittleEndian.Uint32(df.mmap[8:12])
        header.RecordCount = binary.LittleEndian.Uint64(df.mmap[12:20])
        header.Capacity = binary.LittleEndian.Uint64(df.mmap[20:28])
        header.RecordSize = binary.LittleEndian.Uint32(df.mmap[28:32])
        header.Checksum = binary.LittleEndian.Uint32(df.mmap[32:36])
        
        // Reserved bytes are left as zero
        
        return header, nil</span>
}

// writeHeader safely writes the header to memory-mapped data using encoding/binary.
func (df *DataFile) writeHeader(header *DataHeader) error <span class="cov8" title="1">{
        if len(df.mmap) &lt; DataHeaderSize </span><span class="cov0" title="0">{
                return fmt.Errorf("file too small for header")
        }</span>
        
        // Write magic bytes
        <span class="cov8" title="1">copy(df.mmap[0:8], header.Magic[:])
        
        // Write other fields using encoding/binary
        binary.LittleEndian.PutUint32(df.mmap[8:12], header.Version)
        binary.LittleEndian.PutUint64(df.mmap[12:20], header.RecordCount)
        binary.LittleEndian.PutUint64(df.mmap[20:28], header.Capacity)
        binary.LittleEndian.PutUint32(df.mmap[28:32], header.RecordSize)
        binary.LittleEndian.PutUint32(df.mmap[32:36], header.Checksum)
        
        // Clear reserved bytes
        for i := 36; i &lt; DataHeaderSize; i++ </span><span class="cov8" title="1">{
                df.mmap[i] = 0
        }</span>
        
        <span class="cov8" title="1">return nil</span>
}

// getRecordCount atomically reads the record count from the header.
func (df *DataFile) getRecordCount() uint64 <span class="cov8" title="1">{
        if len(df.mmap) &lt; 20 </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov8" title="1">return binary.LittleEndian.Uint64(df.mmap[12:20])</span>
}

// setRecordCount atomically updates the record count in the header.
func (df *DataFile) setRecordCount(count uint64) <span class="cov8" title="1">{
        if len(df.mmap) &gt;= 20 </span><span class="cov8" title="1">{
                binary.LittleEndian.PutUint64(df.mmap[12:20], count)
        }</span>
}

// incrementRecordCount atomically increments the record count by 1.
func (df *DataFile) incrementRecordCount() <span class="cov8" title="1">{
        if len(df.mmap) &gt;= 20 </span><span class="cov8" title="1">{
                current := df.getRecordCount()
                df.setRecordCount(current + 1)
        }</span>
}

// newSecureDataFile creates or opens a data file with security validation.
func newSecureDataFile(path string, capacity uint64, chunkSize int64) (*DataFile, error) <span class="cov8" title="1">{
        // Validate existing file or create securely (always enforced)
        var file *os.File
        var err error
        
        if _, statErr := os.Stat(path); statErr == nil </span><span class="cov8" title="1">{
                // File exists, validate security properties
                if err := validateExistingFile(path); err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("existing file failed security validation: %w", err)
                }</span>
                // #nosec G304 - Secure function with validated path
                <span class="cov8" title="1">file, err = os.OpenFile(path, os.O_RDWR, 0600)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to open existing secure file: %w", err)
                }</span>
        } else<span class="cov8" title="1"> {
                // File doesn't exist, create securely
                file, err = secureFileCreate(path)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to create secure data file: %w", err)
                }</span>
        }
        
        <span class="cov8" title="1">return newDataFileFromHandle(path, file, capacity, chunkSize)</span>
}

// newDataFileFromHandle creates a DataFile from an open file handle.
func newDataFileFromHandle(path string, file *os.File, capacity uint64, chunkSize int64) (*DataFile, error) <span class="cov8" title="1">{
        df := &amp;DataFile{
                path:      path,
                file:      file,
                capacity:  capacity,
                chunkSize: chunkSize,
        }
        
        // Get file info
        stat, err := file.Stat()
        if err != nil </span><span class="cov0" title="0">{
                if closeErr := file.Close(); closeErr != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to stat file: %w (cleanup error: %v)", err, closeErr)
                }</span>
                <span class="cov0" title="0">return nil, fmt.Errorf("failed to stat file: %w", err)</span>
        }
        
        <span class="cov8" title="1">if stat.Size() == 0 </span><span class="cov8" title="1">{
                // New file, initialize it
                if err := df.initialize(); err != nil </span><span class="cov0" title="0">{
                        if closeErr := file.Close(); closeErr != nil </span><span class="cov0" title="0">{
                                return nil, fmt.Errorf("failed to initialize data file: %w (cleanup error: %v)", err, closeErr)
                        }</span>
                        <span class="cov0" title="0">return nil, fmt.Errorf("failed to initialize data file: %w", err)</span>
                }
        } else<span class="cov8" title="1"> {
                // Existing file, map it
                df.fileSize = stat.Size()
                if err := df.mapFile(); err != nil </span><span class="cov0" title="0">{
                        if closeErr := file.Close(); closeErr != nil </span><span class="cov0" title="0">{
                                return nil, fmt.Errorf("failed to map data file: %w (cleanup error: %v)", err, closeErr)
                        }</span>
                        <span class="cov0" title="0">return nil, fmt.Errorf("failed to map data file: %w", err)</span>
                }
                
                // Read and validate header
                <span class="cov8" title="1">header, err := df.readHeader()
                if err != nil </span><span class="cov8" title="1">{
                        if closeErr := df.Close(); closeErr != nil </span><span class="cov0" title="0">{
                                return nil, fmt.Errorf("failed to read header: %w (cleanup error: %v)", err, closeErr)
                        }</span>
                        <span class="cov8" title="1">return nil, fmt.Errorf("failed to read header: %w", err)</span>
                }
                
                <span class="cov8" title="1">if err := validateDataHeader(header); err != nil </span><span class="cov8" title="1">{
                        if closeErr := df.Close(); closeErr != nil </span><span class="cov0" title="0">{
                                return nil, fmt.Errorf("invalid data file header: %w (cleanup error: %v)", err, closeErr)
                        }</span>
                        <span class="cov8" title="1">return nil, fmt.Errorf("invalid data file header: %w", err)</span>
                }
                
                // Set append position to end of current records
                // Check for overflow before conversion
                <span class="cov8" title="1">const maxInt64 = 9223372036854775807
                if header.RecordCount &gt; (maxInt64-DataHeaderSize)/RecordSize </span><span class="cov0" title="0">{
                        // Handle overflow by setting to maximum reasonable position
                        atomic.StoreUint64(&amp;df.appendPos, maxInt64)
                }</span> else<span class="cov8" title="1"> {
                        // Safe conversion - RecordCount is within bounds
                        pos := uint64(DataHeaderSize) + header.RecordCount*RecordSize
                        atomic.StoreUint64(&amp;df.appendPos, pos)
                }</span>
        }
        
        <span class="cov8" title="1">return df, nil</span>
}

// initialize creates a new data file with header.
func (df *DataFile) initialize() error <span class="cov8" title="1">{
        // Calculate initial file size - at least header + one record
        initialSize := int64(DataHeaderSize + RecordSize)
        if df.chunkSize &gt; initialSize </span><span class="cov8" title="1">{
                initialSize = df.chunkSize
        }</span>
        
        // Resize file
        <span class="cov8" title="1">if err := df.file.Truncate(initialSize); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to resize file: %w", err)
        }</span>
        
        <span class="cov8" title="1">df.fileSize = initialSize
        
        // Map the file
        if err := df.mapFile(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to map file: %w", err)
        }</span>
        
        // Create and write header using safe encoding
        <span class="cov8" title="1">header := newDataHeader(df.capacity)
        if err := df.writeHeader(header); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to write header: %w", err)
        }</span>
        
        // Set initial append position
        <span class="cov8" title="1">atomic.StoreUint64(&amp;df.appendPos, DataHeaderSize)
        
        return nil</span>
}

// mapFile memory maps the data file.
func (df *DataFile) mapFile() error <span class="cov8" title="1">{
        // Unmap if already mapped
        if df.mmap != nil </span><span class="cov0" title="0">{
                if err := df.unmapFile(); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }
        
        // Memory map the file
        <span class="cov8" title="1">mmap, err := syscall.Mmap(
                int(df.file.Fd()),
                0,
                int(df.fileSize),
                syscall.PROT_READ|syscall.PROT_WRITE,
                syscall.MAP_SHARED,
        )
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("mmap failed: %w", err)
        }</span>
        
        <span class="cov8" title="1">df.mmap = mmap
        
        // Header is accessed via safe encoding/binary operations in helper functions
        
        return nil</span>
}

// unmapFile unmaps the memory-mapped file.
func (df *DataFile) unmapFile() error <span class="cov8" title="1">{
        if df.mmap != nil </span><span class="cov8" title="1">{
                if err := syscall.Munmap(df.mmap); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("munmap failed: %w", err)
                }</span>
                <span class="cov8" title="1">df.mmap = nil</span>
        }
        <span class="cov8" title="1">return nil</span>
}

// grow expands the data file by at least the specified amount.
func (df *DataFile) grow(minSize int64) error <span class="cov8" title="1">{
        df.mu.Lock()
        defer df.mu.Unlock()
        
        // Calculate new size
        newSize := df.fileSize + df.chunkSize
        if newSize &lt; df.fileSize+minSize </span><span class="cov0" title="0">{
                newSize = df.fileSize + minSize
        }</span>
        
        // Unmap current mapping
        <span class="cov8" title="1">if err := df.unmapFile(); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        
        // Resize file
        <span class="cov8" title="1">if err := df.file.Truncate(newSize); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to resize file: %w", err)
        }</span>
        
        <span class="cov8" title="1">df.fileSize = newSize
        
        // Remap file
        return df.mapFile()</span>
}

// AppendRecord appends a new record to the data file.
func (df *DataFile) AppendRecord(n *needle.Needle, expiration time.Time) (uint64, error) <span class="cov8" title="1">{
        // Check capacity
        if df.getRecordCount() &gt;= df.capacity </span><span class="cov8" title="1">{
                return 0, ErrDataFileFull
        }</span>
        
        // Get current append position
        <span class="cov8" title="1">offset := atomic.LoadUint64(&amp;df.appendPos)
        
        // Check if we need to grow the file
        // Safe conversion: offset is always valid file position
        if offset &gt; 9223372036854775807 || int64(offset)+RecordSize &gt; df.fileSize </span><span class="cov8" title="1">{
                if err := df.grow(RecordSize); err != nil </span><span class="cov0" title="0">{
                        return 0, fmt.Errorf("failed to grow data file: %w", err)
                }</span>
        }
        
        // Create record
        <span class="cov8" title="1">record := newRecord(n, expiration)
        
        // Write record to memory-mapped file
        df.mu.RLock()
        copy(df.mmap[offset:offset+RecordSize], record.Bytes())
        df.mu.RUnlock()
        
        // Update counters atomically
        atomic.AddUint64(&amp;df.appendPos, uint64(RecordSize))
        df.incrementRecordCount()
        
        return offset, nil</span>
}

// UpdateRecord updates an existing record at the given offset.
func (df *DataFile) UpdateRecord(offset uint64, n *needle.Needle, expiration time.Time) error <span class="cov8" title="1">{
        // Validate offset - safe conversion since fileSize is positive
        var maxOffset uint64
        if df.fileSize &lt; 0 </span><span class="cov0" title="0">{
                maxOffset = 0
        }</span> else<span class="cov8" title="1"> {
                maxOffset = uint64(df.fileSize)
        }</span>
        <span class="cov8" title="1">if offset &lt; DataHeaderSize || offset+RecordSize &gt; maxOffset </span><span class="cov0" title="0">{
                return ErrInvalidOffset
        }</span>
        
        // Create new record
        <span class="cov8" title="1">record := newRecord(n, expiration)
        
        // Update record in memory-mapped file
        df.mu.RLock()
        defer df.mu.RUnlock()
        
        // Double-check bounds
        if offset+RecordSize &gt; uint64(len(df.mmap)) </span><span class="cov0" title="0">{
                return ErrInvalidOffset
        }</span>
        
        <span class="cov8" title="1">copy(df.mmap[offset:offset+RecordSize], record.Bytes())
        
        return nil</span>
}

// ReadRecord reads a record from the given offset.
func (df *DataFile) ReadRecord(offset uint64) (*Record, error) <span class="cov8" title="1">{
        // Validate offset - safe conversion since fileSize is positive
        var maxOffset uint64
        if df.fileSize &lt; 0 </span><span class="cov0" title="0">{
                maxOffset = 0
        }</span> else<span class="cov8" title="1"> {
                maxOffset = uint64(df.fileSize)
        }</span>
        <span class="cov8" title="1">if offset &lt; DataHeaderSize || offset+RecordSize &gt; maxOffset </span><span class="cov0" title="0">{
                return nil, ErrInvalidOffset
        }</span>
        
        // Read record from memory-mapped file
        <span class="cov8" title="1">df.mu.RLock()
        recordData := df.mmap[offset : offset+RecordSize]
        record, err := recordFromBytes(recordData)
        df.mu.RUnlock()
        
        return record, err</span>
}

// MarkDeleted marks a record as deleted at the given offset.
func (df *DataFile) MarkDeleted(offset uint64) error <span class="cov8" title="1">{
        // Validate offset - safe conversion since fileSize is positive
        var maxOffset uint64
        if df.fileSize &lt; 0 </span><span class="cov0" title="0">{
                maxOffset = 0
        }</span> else<span class="cov8" title="1"> {
                maxOffset = uint64(df.fileSize)
        }</span>
        <span class="cov8" title="1">if offset &lt; DataHeaderSize || offset+RecordSize &gt; maxOffset </span><span class="cov0" title="0">{
                return ErrInvalidOffset
        }</span>
        
        // Clear active flag directly in memory-mapped file
        <span class="cov8" title="1">df.mu.RLock()
        defer df.mu.RUnlock()
        
        // Ensure offset is within bounds
        if offset+RecordSize &gt; uint64(len(df.mmap)) </span><span class="cov8" title="1">{
                return ErrInvalidOffset
        }</span>
        
        <span class="cov8" title="1">flagsOffset := offset + 200 // Flags are at byte 200 of record
        currentFlags := binary.LittleEndian.Uint64(df.mmap[flagsOffset:flagsOffset+8])
        newFlags := currentFlags &amp;^ ActiveFlag
        binary.LittleEndian.PutUint64(df.mmap[flagsOffset:flagsOffset+8], newFlags)
        
        return nil</span>
}

// GetStats returns statistics about the data file.
func (df *DataFile) GetStats() Stats <span class="cov8" title="1">{
        df.mu.RLock()
        defer df.mu.RUnlock()
        
        stats := Stats{
                TotalRecords: df.getRecordCount(),
                DataFileSize: df.fileSize,
        }
        
        // Count active and expired records
        now := time.Now()
        recordCount := df.getRecordCount()
        for i := uint64(0); i &lt; recordCount; i++ </span><span class="cov8" title="1">{
                // Prevent integer overflow in offset calculation
                if i &gt; (9223372036854775807-DataHeaderSize)/RecordSize </span><span class="cov0" title="0">{
                        break</span>
                }
                <span class="cov8" title="1">offset := int64(DataHeaderSize) + int64(i)*RecordSize
                if offset+RecordSize &gt; df.fileSize </span><span class="cov0" title="0">{
                        break</span>
                }
                
                // Read flags and expiration directly  
                <span class="cov8" title="1">flags := binary.LittleEndian.Uint64(df.mmap[offset+200:offset+208])
                expNanosUint := binary.LittleEndian.Uint64(df.mmap[offset+192:offset+200])
                // Safely convert uint64 to int64, clamping to max int64 to prevent overflow
                var expNanos int64
                if expNanosUint &gt; 9223372036854775807 </span><span class="cov0" title="0">{ // math.MaxInt64
                        expNanos = 9223372036854775807
                }</span> else<span class="cov8" title="1"> {
                        expNanos = int64(expNanosUint)
                }</span>
                
                <span class="cov8" title="1">if (flags &amp; ActiveFlag) != 0 </span><span class="cov8" title="1">{
                        expTime := time.Unix(0, expNanos)
                        if now.After(expTime) </span><span class="cov8" title="1">{
                                stats.ExpiredRecords++
                        }</span> else<span class="cov8" title="1"> {
                                stats.ActiveRecords++
                        }</span>
                } else<span class="cov0" title="0"> {
                        stats.DeletedRecords++
                }</span>
        }
        
        <span class="cov8" title="1">return stats</span>
}

// Sync synchronizes memory-mapped changes to disk.
func (df *DataFile) Sync() error <span class="cov8" title="1">{
        df.mu.RLock()
        defer df.mu.RUnlock()
        
        // Note: msync is platform-specific and not available on all systems
        // The file.Sync() call should be sufficient for most use cases
        return df.file.Sync()
}</span>

// Close closes the data file and releases resources.
func (df *DataFile) Close() error <span class="cov8" title="1">{
        df.mu.Lock()
        defer df.mu.Unlock()
        
        var errs []error
        
        // Unmap memory
        if err := df.unmapFile(); err != nil </span><span class="cov0" title="0">{
                errs = append(errs, err)
        }</span>
        
        // Close file
        <span class="cov8" title="1">if df.file != nil </span><span class="cov8" title="1">{
                if err := df.file.Close(); err != nil </span><span class="cov0" title="0">{
                        errs = append(errs, err)
                }</span>
        }
        
        <span class="cov8" title="1">if len(errs) &gt; 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("close errors: %v", errs)
        }</span>
        
        <span class="cov8" title="1">return nil</span>
}</pre>
		
		<pre class="file" id="file1" style="display: none">package mmap

import (
        "bytes"
        "encoding/binary"
        "fmt"
        "os"
        "sort"
        "sync"
        "syscall"

        "github.com/nomasters/haystack/needle"
)

// Index represents a memory-mapped index file for fast needle lookups.
type Index struct {
        path     string
        file     *os.File
        mmap     []byte
        fileSize int64
        capacity uint64
        mu       sync.RWMutex
}

// readHeader safely reads the header from memory-mapped data using encoding/binary.
func (idx *Index) readHeader() (*IndexHeader, error) <span class="cov8" title="1">{
        if len(idx.mmap) &lt; IndexHeaderSize </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("file too small for header")
        }</span>
        
        <span class="cov8" title="1">header := &amp;IndexHeader{}
        
        // Read magic bytes
        copy(header.Magic[:], idx.mmap[0:8])
        
        // Read other fields using encoding/binary
        header.Version = binary.LittleEndian.Uint32(idx.mmap[8:12])
        header.EntryCount = binary.LittleEndian.Uint64(idx.mmap[12:20])
        header.Capacity = binary.LittleEndian.Uint64(idx.mmap[20:28])
        header.EntrySize = binary.LittleEndian.Uint32(idx.mmap[28:32])
        header.Checksum = binary.LittleEndian.Uint32(idx.mmap[32:36])
        
        // Reserved bytes are left as zero
        
        return header, nil</span>
}

// writeHeader safely writes the header to memory-mapped data using encoding/binary.
func (idx *Index) writeHeader(header *IndexHeader) error <span class="cov8" title="1">{
        if len(idx.mmap) &lt; IndexHeaderSize </span><span class="cov0" title="0">{
                return fmt.Errorf("file too small for header")
        }</span>
        
        // Write magic bytes
        <span class="cov8" title="1">copy(idx.mmap[0:8], header.Magic[:])
        
        // Write other fields using encoding/binary
        binary.LittleEndian.PutUint32(idx.mmap[8:12], header.Version)
        binary.LittleEndian.PutUint64(idx.mmap[12:20], header.EntryCount)
        binary.LittleEndian.PutUint64(idx.mmap[20:28], header.Capacity)
        binary.LittleEndian.PutUint32(idx.mmap[28:32], header.EntrySize)
        binary.LittleEndian.PutUint32(idx.mmap[32:36], header.Checksum)
        
        // Clear reserved bytes
        for i := 36; i &lt; IndexHeaderSize; i++ </span><span class="cov8" title="1">{
                idx.mmap[i] = 0
        }</span>
        
        <span class="cov8" title="1">return nil</span>
}

// getEntryCount atomically reads the entry count from the header.
func (idx *Index) getEntryCount() uint64 <span class="cov8" title="1">{
        if len(idx.mmap) &lt; 20 </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov8" title="1">return binary.LittleEndian.Uint64(idx.mmap[12:20])</span>
}

// setEntryCount atomically updates the entry count in the header.
func (idx *Index) setEntryCount(count uint64) <span class="cov8" title="1">{
        if len(idx.mmap) &gt;= 20 </span><span class="cov8" title="1">{
                binary.LittleEndian.PutUint64(idx.mmap[12:20], count)
        }</span>
}

// incrementEntryCount atomically increments the entry count by 1.
func (idx *Index) incrementEntryCount() <span class="cov8" title="1">{
        if len(idx.mmap) &gt;= 20 </span><span class="cov8" title="1">{
                current := idx.getEntryCount()
                idx.setEntryCount(current + 1)
        }</span>
}

// readEntry safely reads an index entry at the given position using encoding/binary.
func (idx *Index) readEntry(pos int) (needle.Hash, uint64, error) <span class="cov8" title="1">{
        offset := IndexHeaderSize + pos*IndexEntrySize
        if offset+IndexEntrySize &gt; len(idx.mmap) </span><span class="cov0" title="0">{
                return needle.Hash{}, 0, fmt.Errorf("entry position out of bounds")
        }</span>
        
        <span class="cov8" title="1">var hash needle.Hash
        copy(hash[:], idx.mmap[offset:offset+32])
        offsetValue := binary.LittleEndian.Uint64(idx.mmap[offset+32:offset+40])
        
        return hash, offsetValue, nil</span>
}

// writeEntry safely writes an index entry at the given position using encoding/binary.
func (idx *Index) writeEntry(pos int, hash needle.Hash, offset uint64) error <span class="cov8" title="1">{
        entryOffset := IndexHeaderSize + pos*IndexEntrySize
        if entryOffset+IndexEntrySize &gt; len(idx.mmap) </span><span class="cov0" title="0">{
                return fmt.Errorf("entry position out of bounds")
        }</span>
        
        <span class="cov8" title="1">copy(idx.mmap[entryOffset:entryOffset+32], hash[:])
        binary.LittleEndian.PutUint64(idx.mmap[entryOffset+32:entryOffset+40], offset)
        
        return nil</span>
}

// newSecureIndex creates or opens an index file with security validation.
func newSecureIndex(path string, capacity uint64) (*Index, error) <span class="cov8" title="1">{
        // Validate existing file or create securely (always enforced)
        var file *os.File
        var err error
        
        if _, statErr := os.Stat(path); statErr == nil </span><span class="cov8" title="1">{
                // File exists, validate security properties
                if err := validateExistingFile(path); err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("existing index file failed security validation: %w", err)
                }</span>
                // #nosec G304 - Secure function with validated path
                <span class="cov8" title="1">file, err = os.OpenFile(path, os.O_RDWR, 0600)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to open existing secure index file: %w", err)
                }</span>
        } else<span class="cov8" title="1"> {
                // File doesn't exist, create securely
                file, err = secureFileCreate(path)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to create secure index file: %w", err)
                }</span>
        }
        
        <span class="cov8" title="1">return newIndexFromHandle(path, file, capacity)</span>
}

// newIndexFromHandle creates an Index from an open file handle.
func newIndexFromHandle(path string, file *os.File, capacity uint64) (*Index, error) <span class="cov8" title="1">{
        idx := &amp;Index{
                path:     path,
                file:     file,
                capacity: capacity,
        }

        // Get file info
        stat, err := file.Stat()
        if err != nil </span><span class="cov0" title="0">{
                if closeErr := file.Close(); closeErr != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to stat file: %w (cleanup error: %v)", err, closeErr)
                }</span>
                <span class="cov0" title="0">return nil, fmt.Errorf("failed to stat file: %w", err)</span>
        }

        <span class="cov8" title="1">if stat.Size() == 0 </span><span class="cov8" title="1">{
                // New file, initialize it
                if err := idx.initialize(); err != nil </span><span class="cov0" title="0">{
                        if closeErr := file.Close(); closeErr != nil </span><span class="cov0" title="0">{
                                return nil, fmt.Errorf("failed to initialize index file: %w (cleanup error: %v)", err, closeErr)
                        }</span>
                        <span class="cov0" title="0">return nil, fmt.Errorf("failed to initialize index file: %w", err)</span>
                }
        } else<span class="cov8" title="1"> {
                // Existing file, map it
                idx.fileSize = stat.Size()
                if err := idx.mapFile(); err != nil </span><span class="cov0" title="0">{
                        if closeErr := file.Close(); closeErr != nil </span><span class="cov0" title="0">{
                                return nil, fmt.Errorf("failed to map index file: %w (cleanup error: %v)", err, closeErr)
                        }</span>
                        <span class="cov0" title="0">return nil, fmt.Errorf("failed to map index file: %w", err)</span>
                }

                // Read and validate header
                <span class="cov8" title="1">header, err := idx.readHeader()
                if err != nil </span><span class="cov8" title="1">{
                        if closeErr := idx.Close(); closeErr != nil </span><span class="cov0" title="0">{
                                return nil, fmt.Errorf("failed to read header: %w (cleanup error: %v)", err, closeErr)
                        }</span>
                        <span class="cov8" title="1">return nil, fmt.Errorf("failed to read header: %w", err)</span>
                }
                
                <span class="cov8" title="1">if err := validateIndexHeader(header); err != nil </span><span class="cov0" title="0">{
                        if closeErr := idx.Close(); closeErr != nil </span><span class="cov0" title="0">{
                                return nil, fmt.Errorf("invalid index file header: %w (cleanup error: %v)", err, closeErr)
                        }</span>
                        <span class="cov0" title="0">return nil, fmt.Errorf("invalid index file header: %w", err)</span>
                }

                // Note: The index is already populated from the file, no need to rebuild
        }

        <span class="cov8" title="1">return idx, nil</span>
}

// initialize creates a new index file with header.
func (idx *Index) initialize() error <span class="cov8" title="1">{
        // Calculate initial file size
        // Safe conversion: capacity is uint64, IndexEntrySize is const int
        if idx.capacity &gt; (1&lt;&lt;63-1)/IndexEntrySize </span><span class="cov0" title="0">{
                return fmt.Errorf("capacity too large: %d", idx.capacity)
        }</span>
        <span class="cov8" title="1">initialSize := int64(IndexHeaderSize) + int64(idx.capacity)*IndexEntrySize

        // Resize file
        if err := idx.file.Truncate(initialSize); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to resize file: %w", err)
        }</span>

        <span class="cov8" title="1">idx.fileSize = initialSize

        // Map the file
        if err := idx.mapFile(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to map file: %w", err)
        }</span>

        // Create and write header using safe encoding
        <span class="cov8" title="1">header := newIndexHeader(idx.capacity)
        if err := idx.writeHeader(header); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to write header: %w", err)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// mapFile memory maps the index file.
func (idx *Index) mapFile() error <span class="cov8" title="1">{
        // Unmap if already mapped
        if idx.mmap != nil </span><span class="cov0" title="0">{
                if err := idx.unmapFile(); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        // Memory map the file
        <span class="cov8" title="1">mmap, err := syscall.Mmap(
                int(idx.file.Fd()),
                0,
                int(idx.fileSize),
                syscall.PROT_READ|syscall.PROT_WRITE,
                syscall.MAP_SHARED,
        )
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("mmap failed: %w", err)
        }</span>

        <span class="cov8" title="1">idx.mmap = mmap

        // Header is accessed via safe encoding/binary operations in helper functions

        return nil</span>
}

// unmapFile unmaps the memory-mapped file.
func (idx *Index) unmapFile() error <span class="cov8" title="1">{
        if idx.mmap != nil </span><span class="cov8" title="1">{
                if err := syscall.Munmap(idx.mmap); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("munmap failed: %w", err)
                }</span>
                <span class="cov8" title="1">idx.mmap = nil</span>
        }
        <span class="cov8" title="1">return nil</span>
}

// Find searches for a hash in the index and returns its offset.
func (idx *Index) Find(hash needle.Hash) (uint64, bool) <span class="cov8" title="1">{
        idx.mu.RLock()
        defer idx.mu.RUnlock()

        entryCount := idx.getEntryCount()
        if entryCount == 0 </span><span class="cov8" title="1">{
                return 0, false
        }</span>

        // Binary search - safe conversion for array indexing
        <span class="cov8" title="1">if entryCount &gt; 9223372036854775807 </span><span class="cov0" title="0">{
                return 0, false // Index too large for binary search
        }</span>
        <span class="cov8" title="1">left, right := 0, int(entryCount)

        for left &lt; right </span><span class="cov8" title="1">{
                mid := (left + right) / 2
                entryHash, entryOffset, err := idx.readEntry(mid)
                if err != nil </span><span class="cov0" title="0">{
                        return 0, false
                }</span>

                <span class="cov8" title="1">cmp := bytes.Compare(hash[:], entryHash[:])
                switch </span>{
                case cmp == 0:<span class="cov8" title="1">
                        return entryOffset, true</span>
                case cmp &lt; 0:<span class="cov8" title="1">
                        right = mid</span>
                default:<span class="cov8" title="1">
                        left = mid + 1</span>
                }
        }

        <span class="cov8" title="1">return 0, false</span>
}

// findInsertPosition returns the position where a hash should be inserted.
func (idx *Index) findInsertPosition(hash needle.Hash) int <span class="cov8" title="1">{
        entryCount := idx.getEntryCount()

        // Binary search for insertion position - safe conversion for sort.Search
        if entryCount &gt; 9223372036854775807 </span><span class="cov0" title="0">{
                return 9223372036854775807 // Return max safe int for very large indices
        }</span>
        <span class="cov8" title="1">return sort.Search(int(entryCount), func(i int) bool </span><span class="cov8" title="1">{
                entryHash, _, err := idx.readEntry(i)
                if err != nil </span><span class="cov0" title="0">{
                        return false
                }</span>
                <span class="cov8" title="1">return bytes.Compare(entryHash[:], hash[:]) &gt;= 0</span>
        })
}

// Insert adds or updates a hash-to-offset mapping in the index.
func (idx *Index) Insert(hash needle.Hash, offset uint64) error <span class="cov8" title="1">{
        idx.mu.Lock()
        defer idx.mu.Unlock()

        entryCount := idx.getEntryCount()

        // Find insertion position
        pos := idx.findInsertPosition(hash)

        // Check if hash already exists - safe conversion for comparison
        if entryCount &gt; 9223372036854775807 </span><span class="cov0" title="0">{
                return ErrIndexFull // Index too large
        }</span>
        <span class="cov8" title="1">entryCountInt := int(entryCount)
        if pos &lt; entryCountInt </span><span class="cov8" title="1">{
                entryHash, _, err := idx.readEntry(pos)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to read entry: %w", err)
                }</span>
                <span class="cov8" title="1">if bytes.Equal(entryHash[:], hash[:]) </span><span class="cov0" title="0">{
                        // Update existing entry
                        if err := idx.writeEntry(pos, hash, offset); err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("failed to update entry: %w", err)
                        }</span>
                        <span class="cov0" title="0">return nil</span>
                }
        }

        // Check capacity
        <span class="cov8" title="1">if entryCount &gt;= idx.capacity </span><span class="cov0" title="0">{
                return ErrIndexFull
        }</span>

        // Shift entries to make room if necessary
        <span class="cov8" title="1">if pos &lt; entryCountInt </span><span class="cov8" title="1">{
                // Copy entries one position to the right
                for i := entryCountInt; i &gt; pos; i-- </span><span class="cov8" title="1">{
                        srcHash, srcOffset, err := idx.readEntry(i - 1)
                        if err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("failed to read source entry: %w", err)
                        }</span>
                        <span class="cov8" title="1">if err := idx.writeEntry(i, srcHash, srcOffset); err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("failed to write destination entry: %w", err)
                        }</span>
                }
        }

        // Insert new entry
        <span class="cov8" title="1">if err := idx.writeEntry(pos, hash, offset); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to write new entry: %w", err)
        }</span>

        // Update entry count
        <span class="cov8" title="1">idx.incrementEntryCount()

        return nil</span>
}

// ForEach iterates over all entries in the index.
func (idx *Index) ForEach(fn func(needle.Hash, uint64) bool) <span class="cov8" title="1">{
        idx.mu.RLock()
        defer idx.mu.RUnlock()

        entryCount := idx.getEntryCount()

        // Safe conversion for loop iteration
        if entryCount &gt; 9223372036854775807 </span><span class="cov0" title="0">{
                return // Index too large to iterate
        }</span>
        <span class="cov8" title="1">entryCountInt := int(entryCount)
        for i := 0; i &lt; entryCountInt; i++ </span><span class="cov8" title="1">{
                entryHash, entryOffset, err := idx.readEntry(i)
                if err != nil </span><span class="cov0" title="0">{
                        break</span> // Skip invalid entries
                }
                <span class="cov8" title="1">if !fn(entryHash, entryOffset) </span><span class="cov8" title="1">{
                        break</span>
                }
        }
}

// Sync synchronizes memory-mapped changes to disk.
func (idx *Index) Sync() error <span class="cov8" title="1">{
        idx.mu.RLock()
        defer idx.mu.RUnlock()

        // Note: msync is platform-specific
        return idx.file.Sync()
}</span>

// Close closes the index file and releases resources.
func (idx *Index) Close() error <span class="cov8" title="1">{
        idx.mu.Lock()
        defer idx.mu.Unlock()

        var errs []error

        // Unmap memory
        if err := idx.unmapFile(); err != nil </span><span class="cov0" title="0">{
                errs = append(errs, err)
        }</span>

        // Close file
        <span class="cov8" title="1">if idx.file != nil </span><span class="cov8" title="1">{
                if err := idx.file.Close(); err != nil </span><span class="cov0" title="0">{
                        errs = append(errs, err)
                }</span>
        }

        <span class="cov8" title="1">if len(errs) &gt; 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("close errors: %v", errs)
        }</span>

        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package mmap

import (
        "fmt"
        "os"
        "path/filepath"
        "strings"
        "syscall"
)

// Security policies are hardcoded and always enforced:
// - Files must be owned by current user
// - Files must have exactly 0600 permissions
// - No directory restrictions (user can store anywhere)

// validateDataDirectory validates that a directory is safe for storing haystack data.
func validateDataDirectory(dir string) error <span class="cov8" title="1">{
        if dir == "" </span><span class="cov8" title="1">{
                return fmt.Errorf("data directory cannot be empty")
        }</span>

        // Resolve to absolute path to prevent traversal
        <span class="cov8" title="1">_, err := filepath.Abs(dir)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid directory path: %w", err)
        }</span>

        // Check for obvious path traversal attempts
        <span class="cov8" title="1">if strings.Contains(dir, "..") </span><span class="cov8" title="1">{
                return fmt.Errorf("path traversal not allowed in directory: %s", dir)
        }</span>

        // Directory validation passed - user can store anywhere with proper file security

        // Get absolute path for directory creation
        <span class="cov8" title="1">abs, err := filepath.Abs(dir)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to resolve absolute path: %w", err)
        }</span>

        // Create directory if it doesn't exist, with secure permissions
        <span class="cov8" title="1">if err := os.MkdirAll(abs, 0750); err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("failed to create directory %s: %w", abs, err)
        }</span>

        // Validate directory permissions and ownership (always enforced)
        <span class="cov8" title="1">return validateDirectorySecurity(abs)</span>
}

// buildSecureDataPath constructs a safe path for haystack data files.
func buildSecureDataPath(baseDir, filename string) (string, error) <span class="cov8" title="1">{
        if baseDir == "" </span><span class="cov8" title="1">{
                return "", fmt.Errorf("base directory cannot be empty")
        }</span>

        // Ensure filename is safe (no path components)
        <span class="cov8" title="1">if strings.Contains(filename, "/") || strings.Contains(filename, "\\") </span><span class="cov8" title="1">{
                return "", fmt.Errorf("filename cannot contain path separators: %s", filename)
        }</span>

        <span class="cov8" title="1">if strings.Contains(filename, "..") </span><span class="cov8" title="1">{
                return "", fmt.Errorf("filename cannot contain path traversal: %s", filename)
        }</span>

        // Build secure path
        <span class="cov8" title="1">abs, err := filepath.Abs(baseDir)
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("invalid base directory: %w", err)
        }</span>

        <span class="cov8" title="1">return filepath.Join(abs, filename), nil</span>
}

// validateExistingFile validates security properties of an existing file.
func validateExistingFile(path string) error <span class="cov8" title="1">{
        info, err := os.Stat(path)
        if err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("failed to stat file %s: %w", path, err)
        }</span>

        // Ensure it's a regular file
        <span class="cov8" title="1">if !info.Mode().IsRegular() </span><span class="cov8" title="1">{
                return fmt.Errorf("path %s is not a regular file", path)
        }</span>

        // Always enforce strict permissions (opinionated security)
        <span class="cov8" title="1">if info.Mode().Perm() != 0600 </span><span class="cov8" title="1">{
                return fmt.Errorf("file %s must have 0600 permissions, got %o",
                        path, info.Mode().Perm())
        }</span>

        // Always check ownership (opinionated security)
        <span class="cov8" title="1">if err := validateFileOwnership(path, info); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("ownership validation failed for %s: %w", path, err)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// validateDirectorySecurity checks directory permissions and ownership.
func validateDirectorySecurity(dir string) error <span class="cov8" title="1">{
        info, err := os.Stat(dir)
        if err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("failed to stat directory %s: %w", dir, err)
        }</span>

        // Ensure it's a directory
        <span class="cov8" title="1">if !info.IsDir() </span><span class="cov8" title="1">{
                return fmt.Errorf("path %s is not a directory", dir)
        }</span>

        // Always check ownership (opinionated security)
        <span class="cov8" title="1">if err := validateFileOwnership(dir, info); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("directory ownership validation failed for %s: %w", dir, err)
        }</span>

        // Directory should not be world-writable
        <span class="cov8" title="1">if info.Mode().Perm()&amp;0002 != 0 </span><span class="cov8" title="1">{
                return fmt.Errorf("directory %s is world-writable (security risk)", dir)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// validateFileOwnership ensures file is owned by current user.
func validateFileOwnership(path string, info os.FileInfo) error <span class="cov8" title="1">{
        currentUID := os.Getuid()

        stat, ok := info.Sys().(*syscall.Stat_t)
        if !ok </span><span class="cov0" title="0">{
                return fmt.Errorf("unable to get file ownership information for %s", path)
        }</span>

        <span class="cov8" title="1">if int(stat.Uid) != currentUID </span><span class="cov0" title="0">{
                return fmt.Errorf("file %s must be owned by current user (UID %d), got UID %d",
                        path, currentUID, stat.Uid)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// secureFileCreate creates a file with secure permissions and validates ownership.
func secureFileCreate(path string) (*os.File, error)<span class="cov8" title="1">{
        // Validate path is secure
        dir := filepath.Dir(path)
        if err := validateDataDirectory(dir); err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("insecure directory for file %s: %w", path, err)
        }</span>

        // Create file with secure permissions
        // #nosec G304 - Path validated by validateDataDirectory above
        <span class="cov8" title="1">file, err := os.OpenFile(path, os.O_CREATE|os.O_RDWR, 0600)
        if err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("failed to create secure file %s: %w", path, err)
        }</span>

        // Validate the created file meets security requirements
        <span class="cov8" title="1">if err := validateExistingFile(path); err != nil </span><span class="cov8" title="1">{
                var cleanupErrs []error
                if closeErr := file.Close(); closeErr != nil </span><span class="cov0" title="0">{
                        cleanupErrs = append(cleanupErrs, fmt.Errorf("file.Close: %w", closeErr))
                }</span>
                <span class="cov8" title="1">if removeErr := os.Remove(path); removeErr != nil </span><span class="cov0" title="0">{
                        cleanupErrs = append(cleanupErrs, fmt.Errorf("os.Remove: %w", removeErr))
                }</span>

                <span class="cov8" title="1">if len(cleanupErrs) &gt; 0 </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("created file failed security validation: %w (cleanup errors: %v)", err, cleanupErrs)
                }</span>
                <span class="cov8" title="1">return nil, fmt.Errorf("created file failed security validation: %w", err)</span>
        }

        <span class="cov8" title="1">return file, nil</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package mmap

import (
        "context"
        "fmt"
        "os"
        "sync"
        "time"

        "github.com/nomasters/haystack/logger"
        "github.com/nomasters/haystack/needle"
        "github.com/nomasters/haystack/storage"
)

// Store implements the storage.GetSetCloser interface using memory-mapped files.
type Store struct {
        config    *Config
        logger    logger.Logger
        dataFile  *DataFile
        index     *Index
        dataPath  string // Actual path to data file
        indexPath string // Actual path to index file
        mu        sync.RWMutex
        ctx       context.Context
        cancel    context.CancelFunc
        done      chan struct{}
}

// Config holds configuration options for the memory-mapped storage.
type Config struct {
        // DataDirectory is the directory where data files will be stored
        // Files will be created as: {DataDirectory}/haystack.data, {DataDirectory}/haystack.index
        DataDirectory string

        // TTL is the time-to-live for stored needles
        TTL time.Duration

        // MaxItems is the maximum number of items to store
        MaxItems uint64

        // CompactThreshold triggers compaction when this fraction of records are deleted
        CompactThreshold float64

        // GrowthChunkSize is the size increment when growing files (bytes)
        GrowthChunkSize int64

        // SyncWrites forces synchronization after writes
        SyncWrites bool

        // CleanupInterval is how often to run TTL cleanup
        CleanupInterval time.Duration

        // Logger for error and info messages (optional, uses NoOp if nil)
        Logger logger.Logger
}

// DefaultConfig returns a secure configuration with sensible defaults.
func DefaultConfig() *Config <span class="cov8" title="1">{
        return &amp;Config{
                DataDirectory:    ".",
                TTL:              24 * time.Hour,
                MaxItems:         2000000,
                CompactThreshold: 0.25,
                GrowthChunkSize:  1024 * 1024, // 1MB
                SyncWrites:       false,
                CleanupInterval:  2 * time.Hour,
                Logger:           logger.NewNoOp(),
        }
}</span>

// New creates a new memory-mapped store with the given configuration.
func New(ctx context.Context, config *Config) (*Store, error) <span class="cov8" title="1">{
        if config == nil </span><span class="cov8" title="1">{
                config = DefaultConfig()
        }</span>

        // Use current directory if DataDirectory is not provided
        <span class="cov8" title="1">if config.DataDirectory == "" </span><span class="cov8" title="1">{
                config.DataDirectory = "."
        }</span>

        // Validate data directory (security always enforced)
        <span class="cov8" title="1">if err := validateDataDirectory(config.DataDirectory); err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("data directory validation failed: %w", err)
        }</span>

        // Build secure file paths
        <span class="cov8" title="1">dataPath, err := buildSecureDataPath(config.DataDirectory, "haystack.data")
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to build data path: %w", err)
        }</span>

        <span class="cov8" title="1">indexPath, err := buildSecureDataPath(config.DataDirectory, "haystack.index")
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to build index path: %w", err)
        }</span>

        <span class="cov8" title="1">if config.TTL &lt;= 0 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("TTL must be positive")
        }</span>

        <span class="cov8" title="1">if config.MaxItems == 0 </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("MaxItems must be positive")
        }</span>

        // Use NoOp logger if none provided
        <span class="cov8" title="1">log := config.Logger
        if log == nil </span><span class="cov0" title="0">{
                log = logger.NewNoOp()
        }</span>

        <span class="cov8" title="1">sctx, cancel := context.WithCancel(ctx)

        store := &amp;Store{
                config:    config,
                logger:    log,
                dataPath:  dataPath,
                indexPath: indexPath,
                ctx:       sctx,
                cancel:    cancel,
                done:      make(chan struct{}),
        }

        // Initialize data file (always secure)
        dataFile, err := newSecureDataFile(dataPath, config.MaxItems, config.GrowthChunkSize)
        if err != nil </span><span class="cov0" title="0">{
                cancel()
                return nil, fmt.Errorf("failed to create data file: %w", err)
        }</span>
        <span class="cov8" title="1">store.dataFile = dataFile

        // Initialize index (always secure)
        index, err := newSecureIndex(indexPath, config.MaxItems)
        if err != nil </span><span class="cov0" title="0">{
                if closeErr := dataFile.Close(); closeErr != nil </span><span class="cov0" title="0">{
                        cancel()
                        return nil, fmt.Errorf("failed to create index: %w (cleanup error: %v)", err, closeErr)
                }</span>
                <span class="cov0" title="0">cancel()
                return nil, fmt.Errorf("failed to create index: %w", err)</span>
        }
        <span class="cov8" title="1">store.index = index

        // Always rebuild index from data file on startup to ensure consistency
        if dataFile.getRecordCount() &gt; 0 </span><span class="cov8" title="1">{
                // Clear the index first
                index.setEntryCount(0)

                if err := store.rebuildIndex(); err != nil </span><span class="cov0" title="0">{
                        var cleanupErrs []error
                        if closeErr := dataFile.Close(); closeErr != nil </span><span class="cov0" title="0">{
                                cleanupErrs = append(cleanupErrs, fmt.Errorf("dataFile.Close: %w", closeErr))
                        }</span>
                        <span class="cov0" title="0">if closeErr := index.Close(); closeErr != nil </span><span class="cov0" title="0">{
                                cleanupErrs = append(cleanupErrs, fmt.Errorf("index.Close: %w", closeErr))
                        }</span>
                        <span class="cov0" title="0">cancel()

                        if len(cleanupErrs) &gt; 0 </span><span class="cov0" title="0">{
                                return nil, fmt.Errorf("failed to rebuild index: %w (cleanup errors: %v)", err, cleanupErrs)
                        }</span>
                        <span class="cov0" title="0">return nil, fmt.Errorf("failed to rebuild index: %w", err)</span>
                }
        }

        // Start background cleanup
        <span class="cov8" title="1">go store.cleanup()

        return store, nil</span>
}

// Set stores a needle in the memory-mapped storage.
func (s *Store) Set(n *needle.Needle) error <span class="cov8" title="1">{
        if n == nil </span><span class="cov0" title="0">{
                return storage.ErrorNeedleIsNil
        }</span>

        <span class="cov8" title="1">s.mu.Lock()
        defer s.mu.Unlock()

        hash := n.Hash()
        expiration := time.Now().Add(s.config.TTL)

        // Check if needle already exists
        if offset, found := s.index.Find(hash); found </span><span class="cov8" title="1">{
                // Update existing record
                return s.dataFile.UpdateRecord(offset, n, expiration)
        }</span>

        // Add new record
        <span class="cov8" title="1">offset, err := s.dataFile.AppendRecord(n, expiration)
        if err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("failed to append record: %w", err)
        }</span>

        // Add to index
        <span class="cov8" title="1">if err := s.index.Insert(hash, offset); err != nil </span><span class="cov0" title="0">{
                // TODO: Consider rolling back the data file append
                return fmt.Errorf("failed to insert into index: %w", err)
        }</span>

        <span class="cov8" title="1">if s.config.SyncWrites </span><span class="cov8" title="1">{
                if err := s.sync(); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to sync: %w", err)
                }</span>
        }

        <span class="cov8" title="1">return nil</span>
}

// Get retrieves a needle from the memory-mapped storage.
func (s *Store) Get(hash needle.Hash) (*needle.Needle, error) <span class="cov8" title="1">{
        s.mu.RLock()
        defer s.mu.RUnlock()

        // Find record in index
        offset, found := s.index.Find(hash)
        if !found </span><span class="cov8" title="1">{
                return nil, ErrDNE
        }</span>

        // Read record from data file
        <span class="cov8" title="1">record, err := s.dataFile.ReadRecord(offset)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to read record: %w", err)
        }</span>

        // Check if record is active and not expired
        <span class="cov8" title="1">if !record.IsActive() </span><span class="cov0" title="0">{
                return nil, ErrDNE
        }</span>

        <span class="cov8" title="1">if time.Now().After(record.ExpirationTime()) </span><span class="cov8" title="1">{
                // Record is expired, mark as deleted lazily
                go s.markDeleted(offset)
                return nil, ErrDNE
        }</span>

        <span class="cov8" title="1">return record.Needle(), nil</span>
}

// Close closes the memory-mapped storage and releases resources.
func (s *Store) Close() error <span class="cov8" title="1">{
        s.cancel()
        &lt;-s.done // Wait for cleanup goroutine to finish

        var errs []error

        if s.dataFile != nil </span><span class="cov8" title="1">{
                if err := s.dataFile.Close(); err != nil </span><span class="cov0" title="0">{
                        errs = append(errs, fmt.Errorf("data file close: %w", err))
                }</span>
        }

        <span class="cov8" title="1">if s.index != nil </span><span class="cov8" title="1">{
                if err := s.index.Close(); err != nil </span><span class="cov0" title="0">{
                        errs = append(errs, fmt.Errorf("index close: %w", err))
                }</span>
        }

        <span class="cov8" title="1">if len(errs) &gt; 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("close errors: %v", errs)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// sync synchronizes memory-mapped changes to disk.
func (s *Store) sync() error <span class="cov8" title="1">{
        var errs []error

        if err := s.dataFile.Sync(); err != nil </span><span class="cov0" title="0">{
                errs = append(errs, fmt.Errorf("data file sync: %w", err))
        }</span>

        <span class="cov8" title="1">if err := s.index.Sync(); err != nil </span><span class="cov0" title="0">{
                errs = append(errs, fmt.Errorf("index sync: %w", err))
        }</span>

        <span class="cov8" title="1">if len(errs) &gt; 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("sync errors: %v", errs)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// markDeleted marks a record as deleted asynchronously.
func (s *Store) markDeleted(offset uint64) <span class="cov8" title="1">{
        s.mu.Lock()
        defer s.mu.Unlock()

        if err := s.dataFile.MarkDeleted(offset); err != nil </span><span class="cov8" title="1">{
                s.logger.Errorf("Failed to mark record as deleted at offset %d: %v", offset, err)
        }</span>
}

// cleanup runs periodic TTL cleanup and compaction.
func (s *Store) cleanup() <span class="cov8" title="1">{
        defer close(s.done)

        ticker := time.NewTicker(s.config.CleanupInterval)
        defer ticker.Stop()

        for </span><span class="cov8" title="1">{
                select </span>{
                case &lt;-s.ctx.Done():<span class="cov8" title="1">
                        return</span>
                case &lt;-ticker.C:<span class="cov8" title="1">
                        s.performCleanup()</span>
                }
        }
}

// performCleanup removes expired records and triggers compaction if needed.
func (s *Store) performCleanup() <span class="cov8" title="1">{
        s.mu.Lock()
        defer s.mu.Unlock()

        // Count active and deleted records
        stats := s.dataFile.GetStats()

        deletedRatio := float64(stats.DeletedRecords) / float64(stats.TotalRecords)

        // Trigger compaction if too many deleted records
        if deletedRatio &gt; s.config.CompactThreshold </span><span class="cov0" title="0">{
                s.logger.Infof("Starting compaction: %.2f%% of records are deleted", deletedRatio*100)
                if err := s.compact(); err != nil </span><span class="cov0" title="0">{
                        s.logger.Errorf("Failed to compact storage: %v", err)
                        return
                }</span>
                <span class="cov0" title="0">s.logger.Info("Compaction completed successfully")</span>
        }
}

// compact rebuilds the data and index files to remove deleted records.
func (s *Store) compact() error <span class="cov8" title="1">{
        // Create new temporary files
        newDataPath := s.dataPath + ".compact"
        newIndexPath := s.indexPath + ".compact"

        newDataFile, err := newSecureDataFile(newDataPath, s.config.MaxItems, s.config.GrowthChunkSize)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create new data file: %w", err)
        }</span>
        <span class="cov8" title="1">defer func() </span><span class="cov8" title="1">{
                if newDataFile != nil </span><span class="cov0" title="0">{
                        _ = newDataFile.Close()    // Ignore error during cleanup
                        _ = os.Remove(newDataPath) // Ignore error during cleanup
                }</span>
        }()

        <span class="cov8" title="1">newIndex, err := newSecureIndex(newIndexPath, s.config.MaxItems)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create new index: %w", err)
        }</span>
        <span class="cov8" title="1">defer func() </span><span class="cov8" title="1">{
                if newIndex != nil </span><span class="cov0" title="0">{
                        _ = newIndex.Close()        // Ignore error during cleanup
                        _ = os.Remove(newIndexPath) // Ignore error during cleanup
                }</span>
        }()

        // Copy active, non-expired records
        <span class="cov8" title="1">now := time.Now()
        s.index.ForEach(func(hash needle.Hash, offset uint64) bool </span><span class="cov8" title="1">{
                record, err := s.dataFile.ReadRecord(offset)
                if err != nil </span><span class="cov0" title="0">{
                        return true // Continue with next record
                }</span>

                <span class="cov8" title="1">if !record.IsActive() || now.After(record.ExpirationTime()) </span><span class="cov8" title="1">{
                        return true // Skip deleted/expired records
                }</span>

                // Copy to new files
                <span class="cov0" title="0">newOffset, err := newDataFile.AppendRecord(record.Needle(), record.ExpirationTime())
                if err != nil </span><span class="cov0" title="0">{
                        return false // Stop on error
                }</span>

                <span class="cov0" title="0">if err := newIndex.Insert(hash, newOffset); err != nil </span><span class="cov0" title="0">{
                        return false // Stop on error
                }</span>

                <span class="cov0" title="0">return true</span>
        })

        // Sync new files
        <span class="cov8" title="1">if err := newDataFile.Sync(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to sync new data file: %w", err)
        }</span>

        <span class="cov8" title="1">if err := newIndex.Sync(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to sync new index: %w", err)
        }</span>

        // Close old files (errors are not critical here since we're replacing them)
        <span class="cov8" title="1">_ = s.dataFile.Close() // Ignore error, we're replacing the file
        _ = s.index.Close()    // Ignore error, we're replacing the file

        // Atomic replacement
        if err := os.Rename(newDataPath, s.dataPath); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to replace data file: %w", err)
        }</span>

        <span class="cov8" title="1">if err := os.Rename(newIndexPath, s.indexPath); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to replace index file: %w", err)
        }</span>

        // Reopen files (always use secure versions)
        <span class="cov8" title="1">s.dataFile, err = newSecureDataFile(s.dataPath, s.config.MaxItems, s.config.GrowthChunkSize)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to reopen data file: %w", err)
        }</span>

        <span class="cov8" title="1">s.index, err = newSecureIndex(s.indexPath, s.config.MaxItems)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to reopen index: %w", err)
        }</span>

        // Clear the defer cleanup since we successfully replaced
        <span class="cov8" title="1">newDataFile = nil
        newIndex = nil

        return nil</span>
}

// rebuildIndex scans the data file and rebuilds the index.
func (s *Store) rebuildIndex() error <span class="cov8" title="1">{
        s.mu.Lock()
        defer s.mu.Unlock()

        recordCount := s.dataFile.getRecordCount()

        for i := uint64(0); i &lt; recordCount; i++ </span><span class="cov8" title="1">{
                // Safe conversion: i is bounded by recordCount, check for overflow
                if i &gt; (1&lt;&lt;63-1)/RecordSize </span><span class="cov0" title="0">{
                        break</span> // Prevent overflow
                }
                <span class="cov8" title="1">offsetInt64 := int64(DataHeaderSize) + int64(i)*RecordSize
                if offsetInt64 &lt; 0 </span><span class="cov0" title="0">{
                        continue</span> // Skip invalid offset
                }
                <span class="cov8" title="1">offset := uint64(offsetInt64)

                record, err := s.dataFile.ReadRecord(offset)
                if err != nil </span><span class="cov0" title="0">{
                        continue</span> // Skip invalid records
                }

                // Only index active records
                <span class="cov8" title="1">if record.IsActive() </span><span class="cov8" title="1">{
                        needle := record.Needle()
                        if needle != nil </span><span class="cov8" title="1">{
                                hash := needle.Hash()
                                if err := s.index.Insert(hash, offset); err != nil </span><span class="cov0" title="0">{
                                        return fmt.Errorf("failed to insert into index: %w", err)
                                }</span>
                        }
                }
        }

        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">package mmap

import (
        "encoding/binary"
        "time"

        "github.com/nomasters/haystack/needle"
)

const (
        // File format constants
        DataMagic  = "HAYSTDAT" // Data file magic number
        IndexMagic = "HAYSTIDX" // Index file magic number
        
        // Version information
        FormatVersion = uint32(2) // Bumped to v2 for uint64 capacity/count fields
        
        // Record sizes
        RecordSize      = 208 // 192 needle + 8 expiration + 8 flags
        IndexEntrySize  = 40  // 32 hash + 8 offset
        DataHeaderSize  = 64  // Data file header size
        IndexHeaderSize = 64  // Index file header size
        
        // Flag bits
        ActiveFlag = uint64(1 &lt;&lt; 0) // Record is active (not deleted)
        
        // Default capacities
        DefaultMaxRecords = 2000000
        DefaultMaxIndex   = 2000000
)

// DataHeader represents the header of a data file.
type DataHeader struct {
        Magic       [8]byte   // "HAYSTDAT"
        Version     uint32    // Format version
        RecordCount uint64    // Number of records
        Capacity    uint64    // Maximum records
        RecordSize  uint32    // Size of each record (should be 208)
        Checksum    uint32    // Header checksum
        Reserved    [28]byte  // Future expansion (reduced to accommodate larger fields)
}

// IndexHeader represents the header of an index file.
type IndexHeader struct {
        Magic       [8]byte   // "HAYSTIDX"
        Version     uint32    // Format version
        EntryCount  uint64    // Number of index entries
        Capacity    uint64    // Maximum entries
        EntrySize   uint32    // Size of each entry (should be 40)
        Checksum    uint32    // Header checksum
        Reserved    [28]byte  // Future expansion (reduced to accommodate larger fields)
}

// Record represents a single record in the data file.
type Record struct {
        data []byte // Raw record data (208 bytes)
}

// newRecord creates a new record from a needle and expiration time.
func newRecord(n *needle.Needle, expiration time.Time) *Record <span class="cov8" title="1">{
        data := make([]byte, RecordSize)
        
        // Copy needle data (first 192 bytes)
        copy(data[0:192], n.Bytes())
        
        // Set expiration (next 8 bytes)
        expNanos := expiration.UnixNano()
        // Safely convert int64 to uint64, clamping negative values to 0
        if expNanos &lt; 0 </span><span class="cov0" title="0">{
                binary.LittleEndian.PutUint64(data[192:200], 0)
        }</span> else<span class="cov8" title="1"> {
                binary.LittleEndian.PutUint64(data[192:200], uint64(expNanos))
        }</span>
        
        // Set flags (last 8 bytes) - mark as active
        <span class="cov8" title="1">binary.LittleEndian.PutUint64(data[200:208], ActiveFlag)
        
        return &amp;Record{data: data}</span>
}

// recordFromBytes creates a record from raw bytes.
func recordFromBytes(data []byte) (*Record, error) <span class="cov8" title="1">{
        if len(data) != RecordSize </span><span class="cov8" title="1">{
                return nil, ErrInvalidRecord
        }</span>
        
        // Make a copy to ensure we own the data
        <span class="cov8" title="1">recordData := make([]byte, RecordSize)
        copy(recordData, data)
        
        return &amp;Record{data: recordData}, nil</span>
}

// Needle returns the needle stored in this record.
func (r *Record) Needle() *needle.Needle <span class="cov8" title="1">{
        n, _ := needle.FromBytes(r.data[0:192])
        return n
}</span>

// ExpirationTime returns the expiration time of this record.
func (r *Record) ExpirationTime() time.Time <span class="cov8" title="1">{
        expNanosUint := binary.LittleEndian.Uint64(r.data[192:200])
        // Safely convert uint64 to int64, clamping to max int64 to prevent overflow
        if expNanosUint &gt; 9223372036854775807 </span><span class="cov0" title="0">{ // math.MaxInt64
                return time.Unix(0, 9223372036854775807)
        }</span>
        <span class="cov8" title="1">return time.Unix(0, int64(expNanosUint))</span>
}

// Flags returns the flags field of this record.
func (r *Record) Flags() uint64 <span class="cov8" title="1">{
        return binary.LittleEndian.Uint64(r.data[200:208])
}</span>

// IsActive returns true if the record is active (not deleted).
func (r *Record) IsActive() bool <span class="cov8" title="1">{
        return (r.Flags() &amp; ActiveFlag) != 0
}</span>

// MarkDeleted marks the record as deleted.
func (r *Record) MarkDeleted() <span class="cov8" title="1">{
        flags := r.Flags() &amp;^ ActiveFlag // Clear active flag
        binary.LittleEndian.PutUint64(r.data[200:208], flags)
}</span>

// UpdateExpiration updates the expiration time of this record.
func (r *Record) UpdateExpiration(expiration time.Time) <span class="cov8" title="1">{
        expNanos := expiration.UnixNano()
        // Safely convert int64 to uint64, clamping negative values to 0
        if expNanos &lt; 0 </span><span class="cov0" title="0">{
                binary.LittleEndian.PutUint64(r.data[192:200], 0)
        }</span> else<span class="cov8" title="1"> {
                binary.LittleEndian.PutUint64(r.data[192:200], uint64(expNanos))
        }</span>
}

// Bytes returns the raw bytes of this record.
func (r *Record) Bytes() []byte <span class="cov8" title="1">{
        return r.data
}</span>


// Stats provides statistics about the storage.
type Stats struct {
        TotalRecords   uint64 // Total number of records
        ActiveRecords  uint64 // Number of active records
        DeletedRecords uint64 // Number of deleted records
        ExpiredRecords uint64 // Number of expired records
        DataFileSize   int64  // Size of data file in bytes (can be negative for errors)
        IndexFileSize  int64  // Size of index file in bytes (can be negative for errors)
}

// newDataHeader creates a new data file header.
func newDataHeader(capacity uint64) *DataHeader <span class="cov8" title="1">{
        header := &amp;DataHeader{
                Version:    FormatVersion,
                Capacity:   capacity,
                RecordSize: RecordSize,
        }
        copy(header.Magic[:], DataMagic)
        return header
}</span>

// newIndexHeader creates a new index file header.
func newIndexHeader(capacity uint64) *IndexHeader <span class="cov8" title="1">{
        header := &amp;IndexHeader{
                Version:   FormatVersion,
                Capacity:  capacity,
                EntrySize: IndexEntrySize,
        }
        copy(header.Magic[:], IndexMagic)
        return header
}</span>

// validateDataHeader validates a data file header.
func validateDataHeader(header *DataHeader) error <span class="cov8" title="1">{
        if string(header.Magic[:]) != DataMagic </span><span class="cov8" title="1">{
                return ErrCorruptedFile
        }</span>
        
        <span class="cov8" title="1">if header.Version != FormatVersion </span><span class="cov8" title="1">{
                return ErrIncompatibleVersion
        }</span>
        
        <span class="cov8" title="1">if header.RecordSize != RecordSize </span><span class="cov0" title="0">{
                return ErrIncompatibleVersion
        }</span>
        
        <span class="cov8" title="1">return nil</span>
}

// validateIndexHeader validates an index file header.
func validateIndexHeader(header *IndexHeader) error <span class="cov8" title="1">{
        if string(header.Magic[:]) != IndexMagic </span><span class="cov8" title="1">{
                return ErrCorruptedFile
        }</span>
        
        <span class="cov8" title="1">if header.Version != FormatVersion </span><span class="cov0" title="0">{
                return ErrIncompatibleVersion
        }</span>
        
        <span class="cov8" title="1">if header.EntrySize != IndexEntrySize </span><span class="cov0" title="0">{
                return ErrIncompatibleVersion
        }</span>
        
        <span class="cov8" title="1">return nil</span>
}</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
